/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/cases/{case}/assignment": {
    /**
     * Case assignment
     * @description Assign a single case to a user, list or organisation.
     */
    put: operations["cases-case-assignment"];
  };
  "/cases/{case}/assignment/options": {
    /**
     * Case assignment options
     * @description Retrieve available assignment options for a single case.
     */
    post: operations["cases-case-assignment-options"];
  };
  "/cases/assignment": {
    /**
     * Multi case assignment
     * @description Assign multiple cases to a user, list or organisation.
     */
    put: operations["cases-assignment"];
  };
  "/cases/assignment/options": {
    /**
     * Multi case assignment options
     * @description Retrieve available assignment options for multiple cases.
     */
    post: operations["cases-assignment-options"];
  };
  "/contexts/{context}/fragments/contact": {
    /**
     * Load the context fragment
     * @description Load the fragment from the database.
     */
    get: operations["load-fragment"];
    /**
     * Update the context fragment
     * @description Update the fragment in the database.
     */
    put: operations["update-fragment"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    CaseAssignment: {
      /** Format: uuid */
      caseListUuid?: string;
      /** Format: uuid */
      assignedUserUuid?: string;
      /** Format: uuid */
      assignedCaseListUuid?: string;
      /** Format: uuid */
      assignedOrganisationUuid?: string;
      /** Format: date-time */
      staleSince: string;
    };
    Error: {
      /** Format: int32 */
      code: number;
      message: string;
    };
    /** @enum {string} */
    StatusIndexContactTracing: "unknown" | "not_approached" | "not_reachable" | "conversation_started" | "closed_outside_ggd" | "closed_no_collaboration" | "completed" | "new" | "not_started" | "two_times_not_reached" | "callback_request" | "loose_end" | "four_times_not_reached" | "bco_finished" | "closed";
    CovidCaseOrganisation: {
      /** Format: uuid */
      uuid?: string;
      abbreviation?: string;
      name?: string;
      isCurrent?: boolean;
    };
    CovidCaseCaseList: {
      /** Format: uuid */
      uuid: string;
      isQueue: boolean;
      name?: string;
    };
    CovidCaseUser: {
      /** Format: uuid */
      uuid: string;
      isCurrent: boolean;
      name?: string;
    };
    /** @enum {string} */
    PlannerView: "unknown" | "unassigned" | "assigned" | "outsourced" | "queued" | "archived" | "completed";
    /** @enum {string} */
    BCOStatus: "unknown" | "draft" | "open" | "completed" | "archived";
    /**
     * @description BCO Phase
     * @enum {string}
     */
    BCOPhase: "none" | "1" | "2" | "3" | "4" | "5" | "steekproef";
    /** @enum {integer} */
    Priority: 3 | 2 | 1 | 0;
    /** CovidCaseLabel */
    CovidCaseCaseLabel: {
      /** Format: uuid */
      uuid: string;
      label: boolean;
      is_selectable: boolean;
    };
    /** @enum {string} */
    TestResultSource: "coronit" | "manual" | "meldportaal" | "publicWebPortal";
    CovidCase: {
      /** Format: uuid */
      uuid: string;
      /** @example YQ1-361-245 */
      caseId: string;
      /** @example 22345678 */
      hpzoneNumber: null | string;
      /** @example 123A012345678912 */
      testMonsterNumber: null | string;
      contactsCount: number;
      /** Format: date */
      dateOfBirth: string;
      /** Format: date */
      dateOfTest: null | string;
      /** Format: date */
      dateOfSymptomOnset: null | string;
      statusIndexContactTracing: components["schemas"]["StatusIndexContactTracing"];
      statusExplanation: string;
      /** Format: datetime */
      createdAt: string;
      /** Format: datetime */
      updatedAt: string;
      organisation: null | components["schemas"]["CovidCaseOrganisation"];
      assignedOrganisation: null | components["schemas"]["CovidCaseOrganisation"];
      assignedCaseList: null | components["schemas"]["CovidCaseCaseList"];
      assignedUser: null | components["schemas"]["CovidCaseUser"];
      isEditable: boolean;
      isDeletable: boolean;
      isClosable: boolean;
      isReopenable: boolean;
      isAssignable: boolean;
      canChangeOrganisation: boolean;
      isApproved: null | boolean;
      label: null | string;
      plannerView: components["schemas"]["PlannerView"];
      bcoStatus: components["schemas"]["BCOStatus"];
      bcoPhase: components["schemas"]["BCOPhase"];
      wasOutsourced: boolean;
      wasOutsourcedToOrganisation: OneOf<[null, {
        name: string;
      }]>;
      lastAssignedUserName: null | string;
      priority: components["schemas"]["Priority"];
      caseLabels: components["schemas"]["CovidCaseCaseLabel"][];
      hasNotes?: boolean;
      testResults: components["schemas"]["TestResultSource"][];
      /** Format: int32 */
      age: null | number;
      /** Format: int32 */
      vaccinationCount: null | number;
      /** Format: date */
      mostRecentVaccinationDate: null | string;
    };
    CaseAssignmentStatus: {
      caseId: string;
      assignmentStatus: string;
    };
    CaseAssignmentOptionTypeSeparator: {
      type: string;
    };
    CaseAssignmentOptionTypeOption: {
      type?: string;
      label: string;
      isSelected: boolean;
      isEnabled: boolean;
      isQueue?: boolean;
      /** @enum {string} */
      assignmentType?: "caseList" | "organisation" | "user";
      assignment: {
        /** Format: uuid */
        assignedCaseListUuid?: null | string;
        /** Format: uuid */
        assignedOrganisationUuid?: null | string;
        /** Format: uuid */
        assignedUserUuid?: null | string;
      };
    };
    CaseAssignmentOption: components["schemas"]["CaseAssignmentOptionTypeSeparator"] | components["schemas"]["CaseAssignmentOptionTypeOption"] | components["schemas"]["CaseAssignmentOptionTypeMenu"];
    CaseAssignmentOptionTypeMenu: {
      type: string;
      options: components["schemas"]["CaseAssignmentOption"][];
    };
    Fragment: {
      data: {
        schemaVersion: number;
        [key: string]: unknown;
      };
    };
    nonNegativeInteger: number;
    nonNegativeIntegerDefault0: components["schemas"]["nonNegativeInteger"];
    JsonSchemaDraft07: {
      default?: unknown;
      const?: unknown;
      /** Format: uri-reference */
      $id?: string;
      /** Format: uri */
      $schema?: string;
      /** Format: uri-reference */
      $ref?: string;
      $comment?: string;
      title?: string;
      i18n?: string;
      description?: string;
      /** @default false */
      readOnly?: boolean;
      /** @default false */
      writeOnly?: boolean;
      examples?: unknown[];
      multipleOf?: number;
      maximum?: number;
      exclusiveMaximum?: number;
      minimum?: number;
      exclusiveMinimum?: number;
      maxLength?: components["schemas"]["nonNegativeInteger"];
      minLength?: components["schemas"]["nonNegativeIntegerDefault0"];
      /** Format: regex */
      pattern?: string;
      additionalItems?: boolean | components["schemas"]["JsonSchemaDraft07"];
      /** @default true */
      items?: components["schemas"]["JsonSchemaDraft07"] | components["schemas"]["schemaArray"];
      maxItems?: components["schemas"]["nonNegativeInteger"];
      minItems?: components["schemas"]["nonNegativeIntegerDefault0"];
      /** @default false */
      uniqueItems?: boolean;
      contains?: components["schemas"]["JsonSchemaDraft07"];
      maxProperties?: components["schemas"]["nonNegativeInteger"];
      minProperties?: components["schemas"]["nonNegativeIntegerDefault0"];
      required?: components["schemas"]["stringArray"];
      additionalProperties?: boolean | components["schemas"]["JsonSchemaDraft07"];
      /** @default {} */
      definitions?: {
        [key: string]: components["schemas"]["JsonSchemaDraft07"];
      };
      /** @default {} */
      properties?: {
        [key: string]: components["schemas"]["JsonSchemaDraft07"];
      };
      /** @default {} */
      patternProperties?: {
        [key: string]: components["schemas"]["JsonSchemaDraft07"];
      };
      dependencies?: {
        [key: string]: components["schemas"]["JsonSchemaDraft07"] | components["schemas"]["stringArray"];
      };
      propertyNames?: components["schemas"]["JsonSchemaDraft07"];
      enum?: unknown[];
      type?: components["schemas"]["simpleTypes"] | components["schemas"]["simpleTypes"][];
      format?: string;
      contentMediaType?: string;
      contentEncoding?: string;
      if?: components["schemas"]["JsonSchemaDraft07"];
      then?: components["schemas"]["JsonSchemaDraft07"];
      else?: components["schemas"]["JsonSchemaDraft07"];
      allOf?: components["schemas"]["schemaArray"];
      anyOf?: components["schemas"]["schemaArray"];
      oneOf?: components["schemas"]["schemaArray"];
      not?: components["schemas"]["JsonSchemaDraft07"];
    };
    schemaArray: components["schemas"]["JsonSchemaDraft07"][];
    /** @default [] */
    stringArray: string[];
    /** @enum {string} */
    simpleTypes: "array" | "boolean" | "integer" | "null" | "number" | "object" | "string";
    Scoped: {
      /** @example #/properties/name */
      scope: string;
    };
    SchemaBasedCondition: WithRequired<{
      /** @description A JSON schema describing the value that the scope should match on. */
      schema: components["schemas"]["JsonSchemaDraft07"];
    } & components["schemas"]["Scoped"], "schema">;
    Rule: {
      /** @enum {string} */
      effect: "HIDE" | "SHOW" | "ENABLE" | "DISABLE";
      /** @description The condition that must be met for the effect to be applied. Note that this schema is not complete, conditions can for example be nested. To keep things simple we currently only support a flat list of conditions. */
      condition?: OneOf<[components["schemas"]["SchemaBasedCondition"], {
        /** @enum {string} */
        type: "OR" | "AND";
        conditions: components["schemas"]["SchemaBasedCondition"][];
      }]>;
    };
    UiSchemaElement: {
      type: string;
      rule?: components["schemas"]["Rule"];
    };
    UiSchema: components["schemas"]["LayoutElement"] | components["schemas"]["GroupElement"] | components["schemas"]["CategoryElement"] | components["schemas"]["AlertElement"] | components["schemas"]["ControlElement"] | components["schemas"]["CustomControlElement"] | components["schemas"]["ChildFormControlElement"];
    BaseLayoutElement: WithRequired<{
      elements: components["schemas"]["UiSchema"][];
    } & components["schemas"]["UiSchemaElement"], "elements">;
    LayoutElement: WithRequired<({
      /** @enum {string} */
      type: "HorizontalLayout" | "VerticalLayout" | "Categorization";
    }) & components["schemas"]["BaseLayoutElement"], "type">;
    GroupElement: WithRequired<{
      /** @enum {string} */
      type: "Group";
      label?: string;
    } & components["schemas"]["BaseLayoutElement"], "type">;
    CategoryElement: WithRequired<{
      /** @enum {string} */
      type: "Category";
      label: string;
    } & components["schemas"]["BaseLayoutElement"], "type" | "label">;
    AlertElement: WithRequired<({
      /** @enum {string} */
      type: "Alert";
      label?: string;
      description?: string;
      i18n?: string;
      options?: {
        /** @enum {string} */
        variant?: "success" | "info" | "warning" | "error";
      };
    }) & components["schemas"]["UiSchemaElement"], "type">;
    BaseControlElement: {
      label?: string;
      i18n?: string;
    } & components["schemas"]["UiSchemaElement"] & components["schemas"]["Scoped"];
    PlaceHolderOption: {
      placeholder?: string;
    };
    CommonTypeOptions: {
      focus?: boolean;
    };
    StringOptions: {
      multi?: boolean;
    } & components["schemas"]["PlaceHolderOption"] & components["schemas"]["CommonTypeOptions"];
    BooleanOptions: components["schemas"]["CommonTypeOptions"];
    ArrayOptions: {
      addLabel?: string;
      /** @description Show sort buttons for array items, default is false */
      showSortButtons?: boolean;
      noDataLabel?: string;
      detail?: components["schemas"]["UiSchema"];
    } & components["schemas"]["CommonTypeOptions"];
    EnumOptions: ({
      /** @enum {string} */
      format?: "radio" | "radio-button";
    }) & components["schemas"]["PlaceHolderOption"] & components["schemas"]["CommonTypeOptions"];
    ControlElement: ({
      options?: components["schemas"]["StringOptions"] | components["schemas"]["BooleanOptions"] | components["schemas"]["ArrayOptions"] | components["schemas"]["EnumOptions"];
    }) & components["schemas"]["BaseControlElement"];
    BaseCustomControlElement: WithRequired<{
      customRenderer: string;
    } & components["schemas"]["BaseControlElement"], "customRenderer">;
    CustomControlElement: ({
      /** @enum {string} */
      customRenderer?: "Message" | "JsonEditor" | "RadioButtonGroup" | "Table" | "FormLink" | "ChildForm" | "ChildFormCollection";
    }) & components["schemas"]["BaseCustomControlElement"];
    ChildFormControlElement: WithRequired<({
      /** @enum {string} */
      customRenderer?: "ChildForm" | "ChildFormCollection";
      options: {
        detail: components["schemas"]["UiSchema"];
      };
    }) & components["schemas"]["BaseCustomControlElement"], "options">;
    FormConfig: {
      /**
       * @description A JSON schema (Draft 07) describing the data that is used for the form.
       * Even though the actual data will be FormData or FormCollectionData, these
       * meta data properties should not be included in this dataSchema.
       * This JSON schema is used for referencing the data in the uiSchema.
       * And to provide frontend (JSON Schema) validation on the form data.
       */
      dataSchema: components["schemas"]["JsonSchemaDraft07"];
      uiSchema: components["schemas"]["UiSchema"];
    };
    /** Format: uri */
    URL: string;
    FormRequestConfig: {
      href: components["schemas"]["URL"];
      /**
       * @description HTTP method to use for the request, defaults to GET
       * @enum {string}
       */
      method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    };
    /** @description Form error object, a partial type of the AJV error object. See https://jsonforms.io/docs/validation#external-validation-errors */
    FormValidationError: {
      schemaPath?: string;
      instancePath: string;
      keyword?: string;
      message: string;
      params?: Record<string, never>;
    };
    FormMetaData: {
      /** @description An object with links to that is used by the form to perform CRUD actions */
      $links: {
        self?: components["schemas"]["FormRequestConfig"];
        create?: components["schemas"]["FormRequestConfig"];
        update?: components["schemas"]["FormRequestConfig"];
        delete?: components["schemas"]["FormRequestConfig"];
      };
      $validationErrors?: components["schemas"]["FormValidationError"][];
    };
    FormData: components["schemas"]["FormMetaData"];
    FormCollectionData: WithRequired<{
      items: components["schemas"]["FormData"][];
    } & components["schemas"]["FormMetaData"], "items">;
    FormRootData: {
      /** @description An URL that should return the `FormConfig` object for this form. */
      $config: components["schemas"]["URL"];
      /** @description An object with links to other forms that may be referred by the uiSchema (to be opened in a modal) */
      $forms?: unknown;
    } & (components["schemas"]["FormData"] | components["schemas"]["FormCollectionData"]);
  };
  responses: {
    /** @description unexpected error */
    UnexpectedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Null response */
    NullResponse: {
      content: never;
    };
  };
  parameters: {
    /**
     * @description The id of the case to retrieve or modify
     * @example ad06f565-b874-4f7a-b316-e057e8dffb7f
     */
    case: string;
    /** @description XSRF Token */
    xsrfToken: string;
    /**
     * @description The id of the context to retrieve or modify
     * @example ad06f565-b874-4f7a-b316-e057e8dffb7f
     */
    context: string;
    /** @description XSRF Token */
    "xsrfToken-2": string;
    /**
     * @description A datetime for when a user is automatically logged out
     * @example 2023-02-01T14:52:09.650128Z
     */
    inactivityTimerExpiryDate?: string;
    /** @description XSRF Token */
    xsrftoken: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Case assignment
   * @description Assign a single case to a user, list or organisation.
   */
  "cases-case-assignment": {
    parameters: {
      header: {
        "X-XSRF-TOKEN": components["parameters"]["xsrfToken"];
      };
      path: {
        case: components["parameters"]["case"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CaseAssignment"];
      };
    };
    responses: {
      /** @description Current case data */
      200: {
        content: {
          "application/json": components["schemas"]["CovidCase"];
        };
      };
      /** @description Conflicting case */
      409: {
        content: {
          "application/json": components["schemas"]["CaseAssignmentStatus"];
        };
      };
      default: components["responses"]["UnexpectedError"];
    };
  };
  /**
   * Case assignment options
   * @description Retrieve available assignment options for a single case.
   */
  "cases-case-assignment-options": {
    parameters: {
      header: {
        "X-XSRF-TOKEN": components["parameters"]["xsrfToken"];
      };
      path: {
        case: components["parameters"]["case"];
      };
    };
    responses: {
      /** @description List of available assignment options */
      200: {
        content: {
          "application/json": {
            options: components["schemas"]["CaseAssignmentOption"][];
          };
        };
      };
      default: components["responses"]["UnexpectedError"];
    };
  };
  /**
   * Multi case assignment
   * @description Assign multiple cases to a user, list or organisation.
   */
  "cases-assignment": {
    parameters: {
      header: {
        "X-XSRF-TOKEN": components["parameters"]["xsrfToken"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CaseAssignment"] & {
          cases: string[];
        };
      };
    };
    responses: {
      /** @description Some success, but the following cases are conflicting. */
      200: {
        content: {
          "application/json": components["schemas"]["CaseAssignmentStatus"][];
        };
      };
      /** @description Success, there are no conflicting cases */
      204: {
        content: never;
      };
      /** @description All cases in the request are conflicting */
      409: {
        content: {
          "application/json": components["schemas"]["CaseAssignmentStatus"][];
        };
      };
      default: components["responses"]["UnexpectedError"];
    };
  };
  /**
   * Multi case assignment options
   * @description Retrieve available assignment options for multiple cases.
   */
  "cases-assignment-options": {
    parameters: {
      header: {
        "X-XSRF-TOKEN": components["parameters"]["xsrfToken"];
      };
    };
    requestBody: {
      content: {
        "application/json": {
          cases: string[];
        };
      };
    };
    responses: {
      /** @description List of available assignment options */
      200: {
        content: {
          "application/json": {
            options: components["schemas"]["CaseAssignmentOption"][];
          };
        };
      };
      default: components["responses"]["UnexpectedError"];
    };
  };
  /**
   * Load the context fragment
   * @description Load the fragment from the database.
   */
  "load-fragment": {
    parameters: {
      path: {
        context: components["parameters"]["context"];
      };
    };
    responses: {
      /** @description Contact fragment */
      200: {
        content: {
          "application/json": components["schemas"]["Fragment"];
        };
      };
    };
  };
  /**
   * Update the context fragment
   * @description Update the fragment in the database.
   */
  "update-fragment": {
    parameters: {
      path: {
        context: components["parameters"]["context"];
      };
      cookie: {
        xsrftoken: components["parameters"]["xsrfToken-2"];
      };
    };
    responses: {
      /** @description Contact fragment */
      200: {
        content: {
          "application/json": components["schemas"]["Fragment"];
        };
      };
    };
  };
}
